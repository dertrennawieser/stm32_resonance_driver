/*
 * hrtim.c
 *
 *  Created on: Jan 18, 2024
 *      Author: moritz
 */

#include "hrtim.h"

void hrtim_init(bool pulse_skipping)
{
	SET_BIT(RCC->APB2ENR, RCC_APB2ENR_HRTIM1EN);
	SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOAEN);
	SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOBEN);

	// hrtim init sequence reference manual

	// start dll calibration
	SET_BIT(HRTIM1_COMMON->DLLCR, HRTIM_DLLCR_CAL);
	// wait for dll calibration completed
	while(!READ_BIT(HRTIM1_COMMON->ISR, HRTIM_ISR_DLLRDY));
	// enable periodic calibration
	SET_BIT(HRTIM1_COMMON->DLLCR, HRTIM_DLLCR_CALEN);

	// set counter frequency to 170 MHz
	MODIFY_REG(HRTIM1_TIMA->TIMxCR, HRTIM_TIMCR_CK_PSC, 0b101<<HRTIM_TIMCR_CK_PSC_Pos);
	MODIFY_REG(HRTIM1_TIMB->TIMxCR, HRTIM_TIMCR_CK_PSC, 0b101<<HRTIM_TIMCR_CK_PSC_Pos);
	MODIFY_REG(HRTIM1_TIMC->TIMxCR, HRTIM_TIMCR_CK_PSC, 0b101<<HRTIM_TIMCR_CK_PSC_Pos);
	MODIFY_REG(HRTIM1_TIMD->TIMxCR, HRTIM_TIMCR_CK_PSC, 0b101<<HRTIM_TIMCR_CK_PSC_Pos);
	MODIFY_REG(HRTIM1_TIME->TIMxCR, HRTIM_TIMCR_CK_PSC, 0b101<<HRTIM_TIMCR_CK_PSC_Pos);
	MODIFY_REG(HRTIM1_TIMF->TIMxCR, HRTIM_TIMCR_CK_PSC, 0b101<<HRTIM_TIMCR_CK_PSC_Pos);

	// set period to maximum
	HRTIM1_TIMA->PERxR = 0xFFDF;
	HRTIM1_TIMB->PERxR = 0xFFDF;
	HRTIM1_TIMC->PERxR = 0xFFDF;
	HRTIM1_TIMD->PERxR = 0xFFDF;
	HRTIM1_TIME->PERxR = 0xFFDF;
	HRTIM1_TIMF->PERxR = 0xFFDF;

	// enable update on tim A reset
	SET_BIT(HRTIM1_TIMA->TIMxCR, HRTIM_TIMCR_TRSTU);
	//SET_BIT(HRTIM1_TIMA->TIMxCR, HRTIM_TIMCR_TREPU);
	SET_BIT(HRTIM1_TIME->TIMxCR, HRTIM_TIMCR_TAU);
	SET_BIT(HRTIM1_TIMF->TIMxCR, HRTIM_TIMCR_TAU);
	// enable update on timer B and C reset
	SET_BIT(HRTIM1_TIMB->TIMxCR, HRTIM_TIMCR_TRSTU);
	SET_BIT(HRTIM1_TIMC->TIMxCR, HRTIM_TIMCR_TRSTU);
	// enable push pull mode for timer B and C
	SET_BIT(HRTIM1_TIMB->TIMxCR, HRTIM_TIMCR_PSHPLL);
	SET_BIT(HRTIM1_TIMC->TIMxCR, HRTIM_TIMCR_PSHPLL);
	// enable retriggerable mode for timer A, B, C, D, E, F
	SET_BIT(HRTIM1_TIMA->TIMxCR, HRTIM_TIMCR_RETRIG);
	SET_BIT(HRTIM1_TIMB->TIMxCR, HRTIM_TIMCR_RETRIG);
	SET_BIT(HRTIM1_TIMC->TIMxCR, HRTIM_TIMCR_RETRIG);
	SET_BIT(HRTIM1_TIMD->TIMxCR, HRTIM_TIMCR_RETRIG);
	SET_BIT(HRTIM1_TIME->TIMxCR, HRTIM_TIMCR_RETRIG);
	SET_BIT(HRTIM1_TIMF->TIMxCR, HRTIM_TIMCR_RETRIG);
	// enable triggered half mode for tim B and C
	SET_BIT(HRTIM1_TIMB->TIMxCR2, HRTIM_TIMCR2_TRGHLF);
	SET_BIT(HRTIM1_TIMC->TIMxCR2, HRTIM_TIMCR2_TRGHLF);


	// set hrtim external event 1 to comp2_out
	MODIFY_REG(HRTIM1_COMMON->EECR1, HRTIM_EECR1_EE1SRC, HRTIM_EECR1_EE1SRC_0);
	// event generation on rising edge
	MODIFY_REG(HRTIM1_COMMON->EECR1, HRTIM_EECR1_EE1SNS, HRTIM_EECR1_EE1SNS_0); //HRTIM_EECR1_EE4SNS_0 +
	// external event low latency mode
	//SET_BIT(HRTIM1_COMMON->EECR1, HRTIM_EECR1_EE1FAST);

	// set hrtim external event 2 to tim2_trgo
	MODIFY_REG(HRTIM1_COMMON->EECR1, HRTIM_EECR1_EE2SRC, HRTIM_EECR1_EE2SRC_1);
	// event generation on rising edge
	MODIFY_REG(HRTIM1_COMMON->EECR1, HRTIM_EECR1_EE2SNS, HRTIM_EECR1_EE2SNS_0); //HRTIM_EECR1_EE4SNS_0 +
	// external event low latency mode
	//SET_BIT(HRTIM1_COMMON->EECR1, HRTIM_EECR1_EE2FAST);

	// set hrtim external event 3 to tim3_trgo
	MODIFY_REG(HRTIM1_COMMON->EECR1, HRTIM_EECR1_EE3SRC, HRTIM_EECR1_EE3SRC_1);
	// event generation on rising edge
	MODIFY_REG(HRTIM1_COMMON->EECR1, HRTIM_EECR1_EE3SNS, HRTIM_EECR1_EE3SNS_0); //HRTIM_EECR1_EE4SNS_0 +
	// external event low latency mode
	//SET_BIT(HRTIM1_COMMON->EECR1, HRTIM_EECR1_EE3FAST);

	// set hrtim external event 4 to comp1_out
	MODIFY_REG(HRTIM1_COMMON->EECR1, HRTIM_EECR1_EE4SRC, HRTIM_EECR1_EE4SRC_0);
	// event generation on rising edge
	MODIFY_REG(HRTIM1_COMMON->EECR1, HRTIM_EECR1_EE4SNS, HRTIM_EECR1_EE4SNS_0); //HRTIM_EECR1_EE4SNS_0 +
	// external event low latency mode
	//SET_BIT(HRTIM1_COMMON->EECR1, HRTIM_EECR1_EE4FAST);

	// set hrtim external event 5 to comp3_out
	MODIFY_REG(HRTIM1_COMMON->EECR1, HRTIM_EECR1_EE5SRC, HRTIM_EECR1_EE5SRC_0);
	// event generation on falling edge
	MODIFY_REG(HRTIM1_COMMON->EECR1, HRTIM_EECR1_EE5SNS, HRTIM_EECR1_EE5SNS_1); //HRTIM_EECR1_EE5SNS_0 +
	// external event low latency mode
	//SET_BIT(HRTIM1_COMMON->EECR1, HRTIM_EECR1_EE5FAST);

	// set hrtim external event 6 to comp1_out
	MODIFY_REG(HRTIM1_COMMON->EECR2, HRTIM_EECR2_EE6SRC, HRTIM_EECR2_EE6SRC_1);
	// event generation on rising+falling edge
	MODIFY_REG(HRTIM1_COMMON->EECR2, HRTIM_EECR2_EE6SNS, HRTIM_EECR2_EE6SNS_1 + HRTIM_EECR2_EE6SNS_0);
	// event filtering output transition after 4 valid samples at f_hrtim sampling frequency
	MODIFY_REG(HRTIM1_COMMON->EECR3, HRTIM_EECR3_EE6F, HRTIM_EECR3_EE6F_1);

	// set hrtim external event 7 to comp4
	MODIFY_REG(HRTIM1_COMMON->EECR2, HRTIM_EECR2_EE7SRC, HRTIM_EECR2_EE7SRC_0);
	// event generation on falling edge
	// MODIFY_REG(HRTIM1_COMMON->EECR2, HRTIM_EECR2_EE7SNS, HRTIM_EECR2_EE7SNS_1);
	// event generation on low level
	SET_BIT(HRTIM1_COMMON->EECR2, HRTIM_EECR2_EE7POL);
	// event filtering output transition after 8 valid samples at f_hrtim sampling frequency
	MODIFY_REG(HRTIM1_COMMON->EECR3, HRTIM_EECR3_EE7F, HRTIM_EECR3_EE7F_1 + HRTIM_EECR3_EE7F_0);

	// set hrtim external event 8 to comp3_out
	MODIFY_REG(HRTIM1_COMMON->EECR2, HRTIM_EECR2_EE8SRC, HRTIM_EECR2_EE8SRC_1);
	// event generation on rising edge
	MODIFY_REG(HRTIM1_COMMON->EECR2, HRTIM_EECR2_EE8SNS, HRTIM_EECR2_EE8SNS_0); //HRTIM_EECR1_EE4SNS_0 +
	// event filtering output transition after 8 valid samples at f_hrtim sampling frequency
	MODIFY_REG(HRTIM1_COMMON->EECR3, HRTIM_EECR3_EE8F, HRTIM_EECR3_EE8F_1 + HRTIM_EECR3_EE8F_0);

	// set eev9 to comp4
	MODIFY_REG(HRTIM1_COMMON->EECR2, HRTIM_EECR2_EE9SRC, HRTIM_EECR2_EE9SRC_1 + HRTIM_EECR2_EE9SRC_0);
	// event generation on rising edge
	//MODIFY_REG(HRTIM1_COMMON->EECR2, HRTIM_EECR2_EE9SNS, HRTIM_EECR2_EE9SNS_0);
	// event generation on high level
	CLEAR_BIT(HRTIM1_COMMON->EECR2, HRTIM_EECR2_EE9POL);


	/*
	// set hrtim external event 3 to comp6_out
	MODIFY_REG(HRTIM1_COMMON->EECR1, HRTIM_EECR1_EE3SRC, HRTIM_EECR1_EE3SRC_0);
	// event generation on rising edge
	MODIFY_REG(HRTIM1_COMMON->EECR1, HRTIM_EECR1_EE3SNS, HRTIM_EECR1_EE3SNS_0); //HRTIM_EECR1_EE4SNS_0 +
	// external event low latency mode
	SET_BIT(HRTIM1_COMMON->EECR1, HRTIM_EECR1_EE3FAST);
	*/


	// event blanking for ignoring comp 1 and 2 events for quarter period after tim2 trgo, using cmp2 in triggered half mode
	MODIFY_REG(HRTIM1_TIMB->EEFxR1, HRTIM_EEFR1_EE1FLTR, 0b0010<<HRTIM_EEFR1_EE1FLTR_Pos);
	MODIFY_REG(HRTIM1_TIMB->EEFxR1, HRTIM_EEFR1_EE4FLTR, 0b0010<<HRTIM_EEFR1_EE4FLTR_Pos);
	MODIFY_REG(HRTIM1_TIMB->EEFxR2, HRTIM_EEFR2_EE6FLTR, 0b0010<<HRTIM_EEFR2_EE6FLTR_Pos);

	MODIFY_REG(HRTIM1_TIMC->EEFxR1, HRTIM_EEFR1_EE1FLTR, 0b0010<<HRTIM_EEFR1_EE1FLTR_Pos);
	MODIFY_REG(HRTIM1_TIMC->EEFxR1, HRTIM_EEFR1_EE4FLTR, 0b0010<<HRTIM_EEFR1_EE4FLTR_Pos);
	MODIFY_REG(HRTIM1_TIMC->EEFxR2, HRTIM_EEFR2_EE6FLTR, 0b0010<<HRTIM_EEFR2_EE6FLTR_Pos);

	// tim2 trgo blanking using cmp1
	MODIFY_REG(HRTIM1_TIMB->EEFxR1, HRTIM_EEFR1_EE2FLTR, 0b0001<<HRTIM_EEFR1_EE2FLTR_Pos);
	MODIFY_REG(HRTIM1_TIMC->EEFxR1, HRTIM_EEFR1_EE2FLTR, 0b0001<<HRTIM_EEFR1_EE2FLTR_Pos);

	// ocd blanking at beginning of period to avoid tripping on switching noise
	//MODIFY_REG(HRTIM1_TIMB->EEFxR1, HRTIM_EEFR1_EE4FLTR, 0b0010<<HRTIM_EEFR1_EE4FLTR_Pos);

	// event blanking for ignoring period capture events outside of start_freq*F_MAX_MULTIPLIER and start_freq/F_MIN_DIVISOR
	MODIFY_REG(HRTIM1_TIME->EEFxR1, HRTIM_EEFR1_EE1FLTR, 0b1001<<HRTIM_EEFR1_EE1FLTR_Pos);
	MODIFY_REG(HRTIM1_TIME->EEFxR1, HRTIM_EEFR1_EE4FLTR, 0b1001<<HRTIM_EEFR1_EE4FLTR_Pos);
	MODIFY_REG(HRTIM1_TIME->EEFxR2, HRTIM_EEFR2_EE6FLTR, 0b1001<<HRTIM_EEFR2_EE6FLTR_Pos);

	// blanking for ignoring eev1 and 4 for resetting tima before cmp1
	MODIFY_REG(HRTIM1_TIMA->EEFxR1, HRTIM_EEFR1_EE1FLTR, 0b0001<<HRTIM_EEFR1_EE1FLTR_Pos);
	MODIFY_REG(HRTIM1_TIMA->EEFxR1, HRTIM_EEFR1_EE4FLTR, 0b0001<<HRTIM_EEFR1_EE4FLTR_Pos);
	MODIFY_REG(HRTIM1_TIMA->EEFxR2, HRTIM_EEFR2_EE6FLTR, 0b0001<<HRTIM_EEFR2_EE6FLTR_Pos);

	// tim2 trgo eev only during burst for timeout detection
	MODIFY_REG(HRTIM1_TIMF->EEFxR1, HRTIM_EEFR1_EE2FLTR, 0b1100<<HRTIM_EEFR1_EE2FLTR_Pos);

//	// reset tim A on event 4
//	SET_BIT(HRTIM1_TIMA->RSTxR, HRTIM_RSTR_EXTEVNT4);
//	// reset tim A on event 1
//	SET_BIT(HRTIM1_TIMA->RSTxR, HRTIM_RSTR_EXTEVNT1);
	// reset tim A on event 1
	SET_BIT(HRTIM1_TIMA->RSTxR, HRTIM_RSTR_EXTEVNT6);
	// reset tim A on update
	//SET_BIT(HRTIM1_TIMA->RSTxR, HRTIM_RSTR_UPDATE);
	// tim A capture 1 on event 4
	//SET_BIT(HRTIM1_TIMA->CPT1xCR, HRTIM_CPT1CR_EXEV4CPT);
	// tim A capture 1 on event 1
	//SET_BIT(HRTIM1_TIMA->CPT1xCR, HRTIM_CPT1CR_EXEV1CPT);
	// tim A capture 1 on event 1
	//SET_BIT(HRTIM1_TIMA->CPT1xCR, HRTIM_CPT1CR_EXEV6CPT);

	// reset tim B on event 2
	SET_BIT(HRTIM1_TIMB->RSTxR, HRTIM_RSTR_EXTEVNT2);
	// set output 1 on event 2
	SET_BIT(HRTIM1_TIMB->SETx1R, HRTIM_SET1R_EXTVNT2);
	// set output 2 on event 2
	SET_BIT(HRTIM1_TIMB->SETx2R, HRTIM_SET2R_EXTVNT2);
//	// reset tim B on event 1
//	SET_BIT(HRTIM1_TIMB->RSTxR, HRTIM_RSTR_EXTEVNT1);
//	// set output 1 on event 1
//	SET_BIT(HRTIM1_TIMB->SETx1R, HRTIM_SET1R_EXTVNT1);
//	// set output 2 on event 1
//	SET_BIT(HRTIM1_TIMB->SETx2R, HRTIM_SET2R_EXTVNT1);
//	// reset tim B on event 4
//	SET_BIT(HRTIM1_TIMB->RSTxR, HRTIM_RSTR_EXTEVNT4);
//	// set output 1 on event 4
//	SET_BIT(HRTIM1_TIMB->SETx1R, HRTIM_SET1R_EXTVNT4);
//	// set output 2 on event 4
//	SET_BIT(HRTIM1_TIMB->SETx2R, HRTIM_SET2R_EXTVNT4);
	// reset tim B on event 4
	SET_BIT(HRTIM1_TIMB->RSTxR, HRTIM_RSTR_EXTEVNT6);
	// set output 1 on event 4
	SET_BIT(HRTIM1_TIMB->SETx1R, HRTIM_SET1R_EXTVNT6);
	// set output 2 on event 4
	SET_BIT(HRTIM1_TIMB->SETx2R, HRTIM_SET2R_EXTVNT6);
	// reset tim B on update
	//SET_BIT(HRTIM1_TIMB->RSTxR, HRTIM_RSTR_UPDATE);
	// set output 1 on update
	//SET_BIT(HRTIM1_TIMB->SETx1R, HRTIM_SET1R_UPDATE);
	// set output 2 on update
	//SET_BIT(HRTIM1_TIMB->SETx2R, HRTIM_SET2R_UPDATE);
	// tim B capture 1 on update
	SET_BIT(HRTIM1_TIMB->CPT1xCR, HRTIM_CPT1CR_UPDCPT);
	// tim B capture 2 on event 8
	SET_BIT(HRTIM1_TIMB->CPT2xCR, HRTIM_CPT2CR_EXEV8CPT);

	//SET_BIT(HRTIM1_TIMB->RSTx1R, HRTIM_RST1R_CMP2);
	//SET_BIT(HRTIM1_TIMB->RSTx2R, HRTIM_RST2R_CMP2);

	// reset tim C on event 2
	SET_BIT(HRTIM1_TIMC->RSTxR, HRTIM_RSTR_EXTEVNT2);
	// set output 1 on event 2
	SET_BIT(HRTIM1_TIMC->SETx1R, HRTIM_SET1R_EXTVNT2);
	// set output 2 on event 2
	SET_BIT(HRTIM1_TIMC->SETx2R, HRTIM_SET2R_EXTVNT2);
//	// reset tim C on event 1
//	SET_BIT(HRTIM1_TIMC->RSTxR, HRTIM_RSTR_EXTEVNT1);
//	// set output 1 on event 1
//	SET_BIT(HRTIM1_TIMC->SETx1R, HRTIM_SET1R_EXTVNT1);
//	// set output 2 on event 1
//	SET_BIT(HRTIM1_TIMC->SETx2R, HRTIM_SET2R_EXTVNT1);
//	// reset tim C on event 4
//	SET_BIT(HRTIM1_TIMC->RSTxR, HRTIM_RSTR_EXTEVNT4);
//	// set output 1 on event 4
//	SET_BIT(HRTIM1_TIMC->SETx1R, HRTIM_SET1R_EXTVNT4);
//	// set output 2 on event 4
//	SET_BIT(HRTIM1_TIMC->SETx2R, HRTIM_SET2R_EXTVNT4);
	// reset tim B on event 4
	SET_BIT(HRTIM1_TIMC->RSTxR, HRTIM_RSTR_EXTEVNT6);
	// set output 1 on event 4
	SET_BIT(HRTIM1_TIMC->SETx1R, HRTIM_SET1R_EXTVNT6);
	// set output 2 on event 4
	SET_BIT(HRTIM1_TIMC->SETx2R, HRTIM_SET2R_EXTVNT6);
	// reset tim C on update
	//SET_BIT(HRTIM1_TIMC->RSTxR, HRTIM_RSTR_UPDATE);
	// set output C on update
	//SET_BIT(HRTIM1_TIMC->SETx1R, HRTIM_SET1R_UPDATE);
	// set output C on update
	//SET_BIT(HRTIM1_TIMC->SETx2R, HRTIM_SET2R_UPDATE);
	// tim C capture 1 on update
	SET_BIT(HRTIM1_TIMC->CPT1xCR, HRTIM_CPT1CR_UPDCPT);
	// tim C capture 2 on event 8
	SET_BIT(HRTIM1_TIMC->CPT2xCR, HRTIM_CPT2CR_EXEV8CPT);

	// reset tim D on event 8
	SET_BIT(HRTIM1_TIMD->RSTxR, HRTIM_RSTR_EXTEVNT8);

	// reset tim E on update
	//SET_BIT(HRTIM1_TIME->RSTxR, HRTIM_RSTR_UPDATE);
	// reset tim E on eev1
	//SET_BIT(HRTIM1_TIME->RSTxR, HRTIM_RSTR_EXTEVNT1);
	// reset tim E on eev2
	//SET_BIT(HRTIM1_TIME->RSTxR, HRTIM_RSTR_EXTEVNT2);
	// reset tim E on update (tima reset)
	SET_BIT(HRTIM1_TIME->RSTxR, HRTIM_RSTR_UPDATE);
	// reset tim F on eev9
	//SET_BIT(HRTIM1_TIME->RSTxR, HRTIM_RSTR_EXTEVNT9);
//	// tim E capture 1 on event 1
//	SET_BIT(HRTIM1_TIME->CPT1xCR, HRTIM_CPT1CR_EXEV1CPT);
//	// tim E capture 1 on event 4
//	SET_BIT(HRTIM1_TIME->CPT1xCR, HRTIM_CPT1CR_EXEV4CPT);
	// tim E capture 1 on event 1
	SET_BIT(HRTIM1_TIME->CPT1xCR, HRTIM_CPT1CR_EXEV6CPT);
	// set output 2 on cmp3
	SET_BIT(HRTIM1_TIME->SETx2R, HRTIM_SET2R_CMP3);
	// reset output 2 on eev7 (burst end)
	SET_BIT(HRTIM1_TIME->RSTx2R, HRTIM_RST2R_EXTVNT7);

	//SET_BIT(HRTIM1_TIME->RSTx2R, HRTIM_RST2R_UPDATE);

	// reset tim F on update (tima reset)
	SET_BIT(HRTIM1_TIMF->RSTxR, HRTIM_RSTR_UPDATE);
	// reset tim F on eev9
	//SET_BIT(HRTIM1_TIMF->RSTxR, HRTIM_RSTR_EXTEVNT9);
//	// debug
//	SET_BIT(HRTIM1_TIMF->SETx1R, HRTIM_SET1R_EXTVNT1 + HRTIM_SET1R_EXTVNT4);
//	// debug
//	SET_BIT(HRTIM1_TIMF->RSTx1R, HRTIM_RST1R_EXTVNT1 + HRTIM_RST1R_EXTVNT4);
	// debug
	SET_BIT(HRTIM1_TIMF->SETx1R, HRTIM_SET1R_EXTVNT6);
	// debug
	SET_BIT(HRTIM1_TIMF->RSTx1R, HRTIM_RST1R_EXTVNT6);

	// reset output 2 on update
	SET_BIT(HRTIM1_TIMF->RSTx2R, HRTIM_RST2R_UPDATE);
	// set output 2 on cmp1
	SET_BIT(HRTIM1_TIMF->SETx2R, HRTIM_SET2R_CMP1);
	// reset output 2 on cmp3
	SET_BIT(HRTIM1_TIMF->RSTx2R, HRTIM_RST2R_CMP3);
	// reset output 2 on eev7
	SET_BIT(HRTIM1_TIMF->RSTx2R, HRTIM_RST2R_EXTVNT7);
	// tim F capture 2 on event 2
	SET_BIT(HRTIM1_TIMF->CPT2xCR, HRTIM_CPT2CR_EXEV2CPT);

	// hrtim sync source tim A reset
	MODIFY_REG(HRTIM1->sMasterRegs.MCR, HRTIM_MCR_SYNC_SRC, HRTIM_MCR_SYNC_SRC_1);
	// enable positive pulse on sync output
	MODIFY_REG(HRTIM1->sMasterRegs.MCR, HRTIM_MCR_SYNC_OUT, HRTIM_MCR_SYNC_OUT_1);

	// set delayed protection to delayed idle on external event 7 - comp4 for timer B and C
	MODIFY_REG(HRTIM1_TIMB->OUTxR, HRTIM_OUTR_DLYPRT, HRTIM_OUTR_DLYPRT_1 + HRTIM_OUTR_DLYPRT_2);
	MODIFY_REG(HRTIM1_TIMC->OUTxR, HRTIM_OUTR_DLYPRT, HRTIM_OUTR_DLYPRT_1 + HRTIM_OUTR_DLYPRT_2);
	// enable delayed protection for timer B and C
	SET_BIT(HRTIM1_TIMB->OUTxR, HRTIM_OUTR_DLYPRTEN);
	SET_BIT(HRTIM1_TIMC->OUTxR, HRTIM_OUTR_DLYPRTEN);

	// invert outputs
	//SET_BIT(HRTIM1_TIMB->OUTxR, HRTIM_OUTR_POL1);
	//SET_BIT(HRTIM1_TIMB->OUTxR, HRTIM_OUTR_POL2);

	//SET_BIT(HRTIM1_TIMC->OUTxR, HRTIM_OUTR_POL1);
	//SET_BIT(HRTIM1_TIMC->OUTxR, HRTIM_OUTR_POL2);

	// CHB1 - PA10
	MODIFY_REG(GPIOA->AFR[1], GPIO_AFRH_AFRH2, 13<<GPIO_AFRH_AFSEL10_Pos);	//PA10 -> AF13, CHB1
	MODIFY_REG(GPIOA->MODER, GPIO_MODER_MODER10, GPIO_MODER_MODER10_1);

	// CHB2 - PA11
	MODIFY_REG(GPIOA->AFR[1], GPIO_AFRH_AFRH3, 13<<GPIO_AFRH_AFSEL11_Pos);	//PA11 -> AF13, CHB2
	MODIFY_REG(GPIOA->MODER, GPIO_MODER_MODER11, GPIO_MODER_MODER11_1);

	// FLT1 - PA12
	//MODIFY_REG(GPIOA->AFR[1], GPIO_AFRH_AFRH4, 13<<GPIO_AFRH_AFSEL12_Pos);	//PA12 -> AF13, FLT1
	//MODIFY_REG(GPIOA->MODER, GPIO_MODER_MODER12, GPIO_MODER_MODER12_1);

	// CHC1 - PB12
	MODIFY_REG(GPIOB->AFR[1], GPIO_AFRH_AFRH4, 13<<GPIO_AFRH_AFSEL12_Pos);	//PB12 -> AF13, CHC1
	MODIFY_REG(GPIOB->MODER, GPIO_MODER_MODER12, GPIO_MODER_MODER12_1);

	// CHC2 - PB13
	MODIFY_REG(GPIOB->AFR[1], GPIO_AFRH_AFRH5, 13<<GPIO_AFRH_AFSEL13_Pos);	//PB13 -> AF13, CHC2
	MODIFY_REG(GPIOB->MODER, GPIO_MODER_MODER13, GPIO_MODER_MODER13_1);

	// SCOUT - PB3
	//MODIFY_REG(GPIOB->AFR[0], GPIO_AFRL_AFRL3, 12<<GPIO_AFRL_AFSEL3_Pos);	//PB3 -> AF12, SCOUT
	//MODIFY_REG(GPIOB->MODER, GPIO_MODER_MODER3, GPIO_MODER_MODER3_1);
	/*
	// debug outputs
	// CHE2 - PC9
	MODIFY_REG(GPIOC->AFR[1], GPIO_AFRH_AFRH1, 3<<GPIO_AFRH_AFSEL9_Pos);	//PC9 -> AF3, CHE2
	MODIFY_REG(GPIOC->MODER, GPIO_MODER_MODER9, GPIO_MODER_MODER9_1);

	SET_BIT(HRTIM1_COMMON->OENR, HRTIM_OENR_TE2OEN);

	// CHF1 - PC6
	MODIFY_REG(GPIOC->AFR[0], GPIO_AFRL_AFRL6, 13<<GPIO_AFRL_AFSEL6_Pos);	//PC6 -> AF13, CHF1
	MODIFY_REG(GPIOC->MODER, GPIO_MODER_MODER6, GPIO_MODER_MODER6_1);

	SET_BIT(HRTIM1_COMMON->OENR, HRTIM_OENR_TF1OEN);

	// CHF2 - PC7
	MODIFY_REG(GPIOC->AFR[0], GPIO_AFRL_AFRL7, 13<<GPIO_AFRL_AFSEL7_Pos);	//PC7 -> AF13, CHF2
	MODIFY_REG(GPIOC->MODER, GPIO_MODER_MODER7, GPIO_MODER_MODER7_1);

	SET_BIT(HRTIM1_COMMON->OENR, HRTIM_OENR_TF2OEN);
	*/

	// enable delayed protection irq for tim B
	//SET_BIT(HRTIM1_TIMB->TIMxDIER, HRTIM_TIMDIER_DLYPRTIE);

	// enable cpt2 irq for timF - timeout detection
	SET_BIT(HRTIM1_TIMF->TIMxDIER, HRTIM_TIMDIER_CPT2IE);
	NVIC_EnableIRQ(HRTIM1_TIMF_IRQn);

	if(pulse_skipping)
	{
		// timb dma rq delayed protection entry
		// SET_BIT(HRTIM1_TIMB->TIMxDIER, HRTIM_TIMDIER_DLYPRTDE);

		// timc dma rq repetition
		// SET_BIT(HRTIM1_TIMC->TIMxDIER, HRTIM_TIMDIER_REPDE);

		// enable burst mode for tim B and C outputs
		SET_BIT(HRTIM1_TIMB->OUTxR, HRTIM_OUTR_IDLM1);
		SET_BIT(HRTIM1_TIMB->OUTxR, HRTIM_OUTR_IDLM2);
		SET_BIT(HRTIM1_TIMC->OUTxR, HRTIM_OUTR_IDLM1);
		SET_BIT(HRTIM1_TIMC->OUTxR, HRTIM_OUTR_IDLM2);

		// DMA requests for pulse skipping method 2
		// Timer B Capture 2 DMA rq enable on hrtim dma3 channel
		SET_BIT(HRTIM1_TIMB->TIMxDIER, HRTIM_TIMDIER_CPT2DE);
		// Timer C Capture 1 DMA rq enable on hrtim dma4 channel
		SET_BIT(HRTIM1_TIMC->TIMxDIER, HRTIM_TIMDIER_CPT2DE);
		// Timer D Compare 1 DMA rq enable on hrtim dma5 channel
		SET_BIT(HRTIM1_TIMD->TIMxDIER, HRTIM_TIMDIER_CMP1DE);
	}

	// DMA request for lead time frequency tracking
	// Timer E Capture 1 DMA rq enable on hrtim_dma6 channel
	SET_BIT(HRTIM1_TIME->TIMxDIER, HRTIM_TIMDIER_CPT1DE);

	// enable preload
	SET_BIT(HRTIM1_TIMA->TIMxCR, HRTIM_TIMCR_PREEN);
	SET_BIT(HRTIM1_TIMB->TIMxCR, HRTIM_TIMCR_PREEN);
	SET_BIT(HRTIM1_TIMC->TIMxCR, HRTIM_TIMCR_PREEN);
	SET_BIT(HRTIM1_TIME->TIMxCR, HRTIM_TIMCR_PREEN);
	SET_BIT(HRTIM1_TIMF->TIMxCR, HRTIM_TIMCR_PREEN);
}

void hrtim_enableburst(uint16_t idle, uint16_t period)
{
	// burst mode configuration
	// use timer B reset as burst mode clock source
	MODIFY_REG(HRTIM1_COMMON->BMCR, HRTIM_BMCR_BMCLK, HRTIM_BMCR_BMCLK_1);
	// set burst mode compare value to 2 (keep outputs idle for one period)
	HRTIM1_COMMON->BMCMPR = idle-1;
	HRTIM1_COMMON->BMPER = period-1;
	// start burst mode on timer A reset
	//SET_BIT(HRTIM1_COMMON->BMTRGR, HRTIM_BMTRGR_TARST);
	// enable burst mode
	SET_BIT(HRTIM1_COMMON->BMCR, HRTIM_BMCR_BME);
}


